1. 实战调优
   1. select检查
      1. 用户自定义函数：select后面使用了自定义函数。sql返回多少行，则自定义函数就执行多少次
      2. text类型检查：如果select出现text类型的字段，就会消耗大量的网络和IO带宽，由于返回的内容过大超过了max_allowed_packet设置会导致程序报错
      3. group_concat谨慎使用：group_concat是一个字符串聚合函数，会影响Sql的响应时间，如果返回的值过大，超过了max_allowed_packet设置会导致程序报错
      4. 内联子查询：select后面的子查询，Sql返回多少行，则子查询就会执行多少次
   2. from检查
      1. 使用连接查询时，需要格外注意索引会失效的问题
      2. 关联查询和子查询的效率，在绝大多数情况下关联查询会优于子查询
   3. where检查
      1. 索引列被运算：当一个字段是索引时，如果出现在where条件后面，是不能有任何操作的，否则会导致索引失效
      2. **类型转换**：Int类型的字段，传varchar可以走索引；但是varchar类型的字段传Int值无法走索引。最好就是字段是什么类型，传入的值也是什么类型
      3. 列字符集：字符集不匹配时，可能导致索引失效
   4. group by检查
      1. 前缀索引：group by后面的列有索引，索引可以消除排序带来的CPU的消耗，如果是前缀索引，是不能消除排序的
      2. 函数运算
   5. order by检查
      1. 前缀索引：order by后面的列有索引，索引可以消除排序带来的CPU的消耗，如果是前缀索引，是不能消除排序的
      2. 字段顺序：排序字段顺序需要和索引顺序一致，充分利用索引的有序性来消除排序带来的CPU的开销
   6. limit检查
      1. limit m,n：对于limit m,n分页查询，m越大Sql的耗时就会越长。这种情况下，应该先取出主键id，然后通过主键id跟原表进行join关联查询
   7. auto_increment属性：在InnoDB内部是通过一个系统全局变量dict_sys.row_id来计数，row_id是一个8字节的bigint unsigned，InnoDB在设计时只给row_id保留了6个字节的长度，这样row_id取值范围是0--2^48-1，如果id的值达到了最大值，下一个值从0开始继续循环递增，这种情况下会导致数据丢失
   8. NOT NULL属性：字段应尽量加上默认值，如果列中出现了大量的NULL，会影响索引的稳定性
   9. DEFAULT属性：在创建表的时候，建议每个字段尽量都有默认值，理由同上
   10. TEXT类型：不建议使用TEXT类型，一方面由于传输大量的数据表可能超过max_allowed_packet的设置导致程序报错，并一方面，在表上的DML操作都会变得很慢，建议使用es或对象存储OSS来存储和检索
   11. 索引基数：被索引的列唯一值的个数，唯一值越大越好。例如主键索引id的索引基数为100%，并且为聚集索引，可以直接获取到整行的数据，不需要回表，效率是最高的
   12. 前缀索引：对于边长字符串类型varchar(m)，为了减少key_len，可以考虑创建前缀索引，但是前缀索引不能消除group by，order by带来的排序开销。如果字段的实际最大值比m小很多，建议缩小字段长度
   13. 复合索引顺序：MySql遵循的是索引最左匹配原则，对于复合索引，从左到右依次扫描索引列，到遇到第一个范围查询(>=, >, <, <=, between...and...)就会停止扫描
   14. 时间列索引：对于create_time,update_time这种字段，应该默认创建索引







参考：

1. 敖丙工作以来总结的大厂SQL调优姿势：https://mp.weixin.qq.com/s/nEmN4S9JOTVGj5IHyfNtCw

