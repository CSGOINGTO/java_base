1. 索引的基本概念

   1. 索引是指能够帮助数据库快速获取到数据的一种数据结构

   2. 索引的优缺点

      + 优点：
        1. 能够加快对数据的检索，降低数据库IO成本
        2. 通过索引对数据进行排序，降低了数据排序的成本，降低了CPU的消耗

      + 缺点：
        1. 占用空间比较大，数据库不仅需要存储数据库中的数据表中的数据，而且还需要存储数据表中的索引
        2. 索引虽然会提高查询数据的效率，但是在更新和删除数据时，还会更新对应的索引，因此效率会比只更新数据时效率低

2. 索引的类型

   1. 主键索引(PRIMARY)：索引列中的值必须是唯一的，不允许有null。如果没有显式的设置主键索引，则选取第一个非NULL唯一索引作为主键索引，如果还没有，则生成一个隐藏id作为主键索引。主键索引在一个表中只能存在一个。
   2. 普通索引(NORMAL)
   3. 唯一索引(UNIQUE)：索引列中的值必须是唯一的，可以允许为null
   4. 全文索引(FULLTEXT)：只能在文本类型CHAR，VARCHAR,TEXT类型字段上创建全文索引。字段长度比较大时，如果创建普通索引，则进行like模糊查询时，效率比较低。MyISAM和InnoDB都可以使用全文索引
   5. 空间索引(SPATIAL)
   6. 前缀索引：在文本类型如CHAR,VARCHAR,TEXT类型上创建索引，可以指定索引列的长度，但是数值类型不能指定。无法使用前缀索引做order by和group by，而且也无法使用前缀索引做覆盖扫描，前缀索引还有可能导致增加扫描的行数

3. 索引的数据结构

   1. Hash表：查询的效率高，但是不适合经常做范围查询和排序的查询
   2. 二叉树：包括二叉搜索树和平衡二叉树。因为只有二个叉，所以一般树的高度比较高，因此，每次查找时，所需的磁盘IO比较多，因此性能比较差。不支持范围查找的快速查找，只能从根节点开始，一次次的遍历查找，效率很低
   3. B树
      1. 结构
         1. 多叉树，数据量千万时，树的高度在3或4
         2. 节点中包含键值和数据，节点中的键值按照从小到大排列
         3. 父节点中的元素不会出现在子节点中
         4. 所有的叶子节点都位于同一层，叶子节点具有相同的深度，叶子节点之间没有指针连接
      2. 缺点
         1. 不支持快速范围查找，从根节点查找到某个子节点之后还需要回到根节点再去查找下一个子节点，因此磁盘IO的次数比较多，效率低
         2. 节点中存有数据，因此随着数据中行树的增加，所占的空间会变大，每一页中存储的数据量就会变少，树的高度会增加，查询时所需IO的次数就会增加
   4. B+树
      1. 结构
         1. 多叉树，数据量千万时，树的高度在3或4
         2. 非叶子节点中只存储键值，节点中的键值按照从小到大排列
         3. 叶子节点中存储数据，叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向链表
      2. 优点
         1. 每次查找数据时都需要检索到叶子节点，但是因为非叶子节点中只存储键值，并且是多叉树，因此树的高度一般都会很低。而查找到某个叶子节点之后，因为叶子节点之间有指针相连（相当于双向链表），因此对于范围查找的话，效率也很高。而因为叶子节点中的数据都是有序的，所以对数据排序的效率也会非常的高。
   5. 索引的优化
      1. 使用覆盖索引：如果查询到的列和索引列相同时，则通过B+树查到到叶子节点时，就可以把所需的数据拿到，不需要再通过获取到主键Id，再次到聚集索引中查找数据，减少了磁盘的IO次数
      2. 使用联合索引：将多个索引列组合成一个索引，并把区分度高的索引列放到左侧
   6. 索引设计的三星准则
      1. where后面参与查询的列可以组成单列索引或联合索引
      2. 避免排序，如果sql语句中出现了order by，则取出来的结果是已经按照column排序好的，不需要再生成临时表
      3. select对应的列应该尽量是索引列，尽量避免回表查询
   7. Mysql查询的子句
      1. where
      2. group by
      3. having：有group by才能有having子句，只有满足“条件表达式”中指定的条件才能够输出
      4. order by：默认升序ASC，降序为DESC
      5. limit
   8. 子查询：将查询到的结果作为另外一个sql语句中的where条件或者from表或者exists表。在执行时，会临时创建一张临时表，查询完之后再删除这些临时表。
   9. 连接查询
      1. 笛卡尔积：一个表中有100条数据，另一个表中有100条数据，则这两个表的笛卡尔积为100*100 = 1W
      2. 全相乘 from a, b，这样会将a表和b表的数据做个笛卡尔积，最终的数据量很大，而且还没有索引
      3. 左连接(left join)，A left join B，以A表为主表，B表根据查询条件去一条条匹配，没有满足条件的记录，B表返回null
      4. 右连接(right join)，A right join B，同左连接
      5. 内连接(inner join)，取左连接和右连接的交集，如果两边都不能匹配条件，则都不取出
      6. 联合查询(union)：取左连接和右连接的并集
         1. union：会过滤掉重复的行
         2. union all：不会过滤重复的行











参考： 

1. https://s1973.top/blog/001564220564497e6e1f52f77d54cd2a450d75cc0a581fb000