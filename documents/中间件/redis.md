1. Redis的基本数据类型

   | 类型     | 简介 | 特性 | 场景 | 命令 |
   | :------ | ----------- | ----------- | ----------- | ------- |
   | String(字符串) | 二进制安全 | 可以包含任何数据，比如jpg图片或者序列化的对象，String类型的值最大能存储512MB |      | set、get、incr、incrby |
   | Hash(字典) | 键值对(Key->Value)集合，是一个String类型的值和kv键值对的映射表 | 特别适合存储对象，并且可以像数据库中update一个属性一样只修改某一项属性值。每个hash可以存储2^32-1个键值对 | 存储、读取、修改 | hmset、hmget、hset、hget、hlen、hkeys、hdel |
   | List(列表) | 链表(双向而非循环链表) | 按照插入的顺序排序，可以添加一个元素到列表的头部(左边)或者尾部(右边) | 1. 最新消息排列<br />2. 消息队列 | lpush、rpush、lpop、rpop、rpoplpush、brpoplpush、lrem、blpop |
   | Set(集合) | Hash表实现，元素不重复 | 1. 通过Hash表实现，添加，删除，查找的时间复杂度都是O(1)<br />2. 为集合提供了求交集、并集、差集等操作 | 1. 共同好友<br /> 2. 好友推荐 | sadd、sdiff(差集)、smembers、sinter(交集)、sunion(并集)、spop、srem |
   | Sorted Set(有序集合) | 将Set中的元素增加一个权重参数score，元素按score有序排列 | 数据插入集合时，已经进行天然排序 | 1.排行榜<br />2. 带权重的消息队列 | zadd、zrem、zrange、zincrby、zrank、zscore、zunionstore、zinterstore |
   
2. Redis键过期键删除策略

   + 可能的删除策略
     1. 定时删除：在设置键的过期时间的同时，创建一个定时器(timer)，让定时器在键的过期时间来临时，立即执行对键的删除操作（对内存是最为友好的，但是创建定时器需要用到Redis服务器的时间事件，时间事件的实现方式是无序链表，查找一个事件的时间复杂度O(N)，并不能高效的处理大量的时间事件）
     2. 惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键（对内存不友好，如果有些键不再访问，可以理解为广义上的内存泄漏）
     3. 定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定
   + Redis键过期删除策略：使用的是惰性删除和定期删除的结合
     1. 被动删除：所有读写数据库的Redis命令，在执行之前都会调用expireIfNeeded函数对输入键进行检查，当读/写一个已经过期的key时，会触发惰性删除策略，直接删除这个过期key
     2. 主动删除：由于惰性删除策略无法保证冷数据及时删掉，所以Redis会定期主动淘汰一批已过期的key。在设置的时间内，分多次遍历服务器中的各个数据库，随机检查一部分键的过期时间，并删除其中的过期键。
     3. 当前已用内存超过maxmemory限定时，触发主动清理策略

3. AOF、RDB和复制功能对过期键的处理

   1. RDB处理方法
      1. 在执行`BGSAVE`命令或`SAVE`命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中
      2. 在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将载入RDB文件
         1. 如果服务器以**主服务器模式**运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，**未过期的键会被载入到数据库中，而过期的键则会被忽略**
         2. 如果服务器以**从服务器模式**运行，那么在载入RDB文件时，文件中的**所有的键都会被载入到数据库中**，在之后的数据同步时，从服务器中过期的键会被清空
   2. AOF处理：
      1. 如果键已经过期，但是还没有被惰性删除或定期删除，AOF文件不会因为这个过期键产生任何影响
      2. 如果过期键被惰性删除或定期删除，则会在AOF文件中显示的追加一条**DEL命令**来记录该键已被删除
      3. 在AOF执行重写(BGREWRITEAOF)的过程中，程序会对数据库中的键进行检查，**已过期的键不会被保存到重写后的AOF文件中**
   3. 复制：当服务运行在复制模式下时，**从服务器的过期键删除动作由主服务器控制**。通过由主服务器来控制从服务器统一删除过期键，可以保证主从服务器数据的一致性，也正是这个原因，当主服务器中存在某些过期键时，从服务器中也会存在

4. 时间类命令

   1. 通过`expire`或`pexpire`命令，客户端可以以秒或毫秒为精度，为数据库中的某个键设置生存时间(Time To Live, TTL)
   2. 通过`expireat`或`pexpireat`命令，以秒或者毫秒精度，为数据库中某个键设置过期时间(expire time)
   3. `expire`、`pexpire`和`expireat`命令都是通过转换为`pexpireat`命令来执行
   4. `persist`命令：移除一个键的过期时间
   5. ttl命令：以秒为单位返回键的剩余生存时间；pttl命令：为毫秒为单位返回键的剩余生存时间

5. 大量key在同一时间过期，需要注意什么？

6. redis分布式锁

7. keys获取指定模式的key列表

8. scan命令

9. Redis做异步队列

   一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。如果不sleep的话，还可以使用blpop命令，在没有消息的时候，它会阻塞指到消息到来。

10. 队列，生产一个消息，多次消费

   使用pub/sub主题订阅者模式，可以实现1：N的消息队列

11. pub/sub主题订阅模式的缺点

    在消费者下线的情况下，生产的消息会丢失，这种需要使用专业的Mq消息队列中间件进行解决

12. Redis实现延时队列

    使用sortedset，时间戳作为score，消息内容作为key，调用zadd来生产消息，消费者用zrangebyscore命令获取N秒之前的数据轮询进行处理

13. Redis持久化

    Redis启动时判断有没有开启AOF持久化，如果开启，则使用AOF文件来还原数据库状态；如果没有开启，则使用RDB文件来还原数据库状态(RDB文件载入是由服务器自动执行的，但是必须要在没有开启AOF持久化功能的基础上执行)。

    1. RDB持久化：通过保存数据库中的**键值对**来保存数据库的状态

       1. `SAVE`命令：阻塞Redis服务器进程，直到RDB文件创建完成，在服务器进程阻塞期间，服务器不能处理任何命令请求
       2. `BGSAVE`命令：派生出一个**子进程**，然后由子进程负责创建RDB文件，服务器进程(父进程)继续处理命令请求。在执行`BGSAVE`命令期间，`save`、`bgsave`和`bgrewriteaof`命令不能执行
       3. 载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成
       4. 用户可以通过设置Redis服务器配置的**save**选项，让服务器每隔一段时间自动执行一次`BGSAVE`命令。默认为900s内，至少修改了一次；300s内，至少修改了10次；60s内，至少修改了10000次
       5. 可以使用`od`命令来查看RDB文件内容
    2. AOF持久化：通过保存Redis服务器执行的**写命令**来记录数据库状态
    1. 被写入AOF文件的所有的命令都是以**Redis的命令请求协议格式**保存的
       2. appendfsync配置：
          1. 默认为**everysec**，将aof_buf缓存区中的所有的内容写入到AOF文件，如果上次同步AOF文件的时间距离现在超过1秒，那么再次对AOF文件进行同步，并且这个同步操作是由一个**线程**专门负责执行的。**效率挺高**，出现故障的话，最多丢失**1s**的命令数据
          2. **always**，将aof_buf缓冲区中的所有内容写入并同步到AOF文件。**效率是最慢的**，但是是最安全的，即使出现故障，**最多**也只会**丢失一个事件循环**中所产生的命令数据
          3. **no**，将aof_buf缓冲区中的所有内容写入到AOF文件，但并不对AOF文件进行同步，何时同步由操作系统来决定。AOF文件写入速度最快，但是单次写入数据量是最大的，出现故障，会丢失**上次同步AOF文件之后**所有的写命令数据
       3. AOF文件的载入与数据还原
          1. 创建一个**不带网络连接的伪客户端**(fake client)
          2. 从AOF文件中分析并读取出一条写命令
          3. 使用伪客户端执行被读出的写命令
          4. 一直执行上述2和3，直到AOF文件中的所有的写命令都被处理完毕为止
       4. AOF重写：因为AOF持久化是通过保存被执行的写命令来记录数据库状态，因此随着时间的流逝，AOF文件中的内容会越来越多，文件的体积会越来越大，并且AOF文件的体积越大，使用AOF文件进行数据还原所需的时间就越多。为了解决这个文件，Redis提供了AOF文件重写功能。通过该功能，**Redis服务器可以创建一个新的AOF文件来代替现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但是新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比旧AOF文件体积小很多。**该功能是**通过读取服务器当前的数据库状态来实现的**，而不是通过分析现有的AOF文件
       5. 使用**AOF重写缓存区**，来解决执行写入AOF文件期间，由于服务器处理命令，导致重写后的AOF文件与当前服务器状态不一致的情况。
       6. BGREWRITEAOF命令执行期间，服务器进行操作：
          1. 执行客户端发来的命令
          2. 将执行后的写命令追加到**AOF缓冲区**
          3. 将执行后的写命令追加到**AOF重写缓冲区**
       7. 在`BGWRITEAOF`**执行子进程**执行完毕之后，会向**父进程**发送一个信号，父进程在接收到该信号之后，会调用一个信号处理函数，并执行一下工作。在执行完工作之后，父进程就可以继续像往常一样接受命令请求了。这样将AOF重写对服务器性能造成的影响降到了最低。
          1. 将**AOF重写缓冲区**中的所有内容写入到新AOF文件中，这是新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致
          2. 对新的AOF文件进行改名，原子地覆盖现有的AOF文件，完成新旧两个AOF文件的替换。

14. RDB原理

    fork和cow，fork指redis通过创建子进程来进行RDB操作，cow指copy on write

15. Pipeline有什么好处，为什么要用pipeline

16. Redis同步机制

17. Redis集群










参考：

1. Redis 命令参考：http://doc.redisfans.com/