#### 进程与线程

1. 进程  

   一个正在运行的程序，被称为进程，是程序运行的最小单位。系统运行一个程序即是一个进程从创建，运行到消亡的过程。

2. 线程  

   线程是比进程更小的执行单位。一个进程在其执行的过程中可能会产生多个线程。

   Java中的线程的内存划分有：

   + 堆内存区：存放对象，细分为年轻代和老年代
   + 方法区：存储已被虚拟机加载的类信息，常亮，静态变量等数据

   + 程序计数器：当前程序所执行到字节码的行号

   + 本地方法栈：**为虚拟机使用到的Native方法服务**

   + 栈内存区：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。**每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程**。会抛出**StackOverflowError** 和**OutOfMemoryError**两种异常

     

#### 并发和并行

1. 并发：同一个时间段内，宏观上看多个任务同时运行，微观上多个任务在一段时间内交替运行，在同一时间单个运行；
2. 并行：单位时间内，多个任务同时运行。



#### 线程的生命周期和状态

1. 线程的生命周期和状态
   + NEW：初始状态，线程被构建，但是还没有调用start()方法
   + RUNNING：运行状态
     + RUNNABLE和READY状态之间可以通过yield()方法进行调度
   + READY：就绪状态
     + READY状态的线程在获取到时间片之后就处于RUNNING状态
   + BLOCKED：阻塞状态
     + 等待进入synchronized方法/块时，线程处于BLOCKED状态
     + 获取到锁之后，进入到READY状态
   + WAITING：等待状态
     + 调用Object.wait(),Thread.join(),LockSupport.park()进入该状态
     + 调用Object.notify(),Object.notifyAll(),LockSupport.unpark(Thread)从WAITING状态回到READY状态
   + TIME_WAITING：超时等待状态
     + 调用Thread.sleep(long),Object.wait(long),Thread.join(long),LockSupport.parkNanos(),LockSupport.parkUntil()进入到该状态
     + 调用Object.notify(),Object.notifyAll(),LockSupport.unpark(Thread)从TIME_WAITING状态回到READY状态
   + TERMINATED：终止状态

![](..\image\线程状态.png)

![线程状态间切换](..\image\线程状态间切换.png)

#### 死锁

1. 什么是死锁：多个线程处于阻塞状态，它们中的一个或者多个都在等待对方的某个资源被释放。  

   例如：线程A持有资源1等待获取资源2，线程2持有资源2等待获取资源1，由于它们都想申请对方的资源，因此这两个资源就会互相等待进入死锁状态。

2. 产生死锁的条件：

   1. 互斥条件：该资源任意一个时刻只由一个线程占用。
   2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
   3. 不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
   4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
   
3. 如何避免产生死锁

   1. **破坏互斥条件** ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。
   
   2. **破坏请求与保持条件**  ：一次性申请所有的资源。
   
   3. **破坏不剥夺条件** ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
   
   4. **破坏循环等待条件** ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。
   
#### sleep()和wait()方法的区别和共同点：

   1. sleep()方法不释放锁，wait()方法释放锁
   
   2. 两者都可以暂停线程的执行
   
   3. wait()通常用于线程间交互/通信，sleep()通常用于暂停执行
   
   4. wait()方法被调用后，线程不会自动苏醒（wait(long)方法超时后会自动苏醒），需要其他线程调用同一个对象的notify()或notifyAll()方法。sleep()方法执行完后，线程会自动苏醒。

#### 启动线程调用start()而不是run()

**调用 `start()` 方法方可启动线程并使线程进入就绪状态，直接执行 `run()` 方法的话不会以多线程的方式执行。**

#### Synchronized关键字

1. 作用：解决多个线程之前访问资源的同步性，synchronized关键字可以保证被它修饰的方法或代码块在任意时刻只能有一个线程执行。

   synchronized在**JDK1.6**之前属于重量级锁，效率低下。在1.6之后在**JVM层面**对synchronized有了很大的优化。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。

2. 使用

   + 修饰实例方法
   + 修饰静态方法
   + 修饰代码块

3. synchronized底层原理
   + monitorenter指令：**同步代码块开始的位置。** 在执行monitorenter时，会尝试获取对象锁，如果锁的计数器为0，则表示锁可以被获取，获取后将锁计数器+1，即设置为1。
   + monitorexit指令：**同步代码块结束的位置。** 在执行monitorexit指令后，将锁计数器设为0，表示锁被释放。如果获取对象锁失败，那当前线程就要进入BLOCKED状态，直到对象锁被另外一个线程释放为止。
   + ACC_SYNCHRONIZED标识：**synchronized修饰的方法使用ACC_SYNCHRONIZED标识，表示该方法是一个同步方法。** JVM通过ACC_SYNCHRONIZED标识来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。