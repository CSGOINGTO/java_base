1. Comparable和Comparator区别

   **Comparable:**

   Comparable可以认为是一个**内比较器**，实现了Comparable接口的类有一个特点，就是这些类是可以和自己比较的，至于具体和另一个实现了Comparable接口的类如何比较，则依赖compareTo方法的实现，compareTo方法也被称为**自然比较方法**。如果开发者add进入一个Collection的对象想要Collections的sort方法帮你自动进行排序的话，那么这个对象必须实现Comparable接口。compareTo方法的返回值是int，有三种情况：

   1、比较者大于被比较者（也就是compareTo方法里面的对象），那么返回正整数

   2、比较者等于被比较者，那么返回0

   3、比较者小于被比较者，那么返回负整数

   **Comparator**:

   Comparator可以认为是是一个**外比较器**，个人认为有两种情况可以使用实现Comparator接口的方式：

   1、一个对象不支持自己和自己比较（没有实现Comparable接口），但是又想对两个对象进行比较

   2、一个对象实现了Comparable接口，但是开发者认为compareTo方法中的比较方式并不是自己想要的那种比较方式

   Comparator接口里面有一个compare方法，方法有两个参数T o1和T o2，是泛型的表示方式，分别表示待比较的两个对象，方法返回值和Comparable接口一样是int，有三种情况：

   1、o1大于o2，返回正整数

   2、o1等于o2，返回0

   3、o1小于o3，返回负整数

   **总结**

   总结一下，两种比较器Comparable和Comparator，后者相比前者有如下优点：

   1、如果实现类没有实现Comparable接口，又想对两个类进行比较（或者实现类实现了Comparable接口，但是对compareTo方法内的比较算法不满意），那么可以实现Comparator接口，自定义一个比较器，写比较算法

   2、实现Comparable接口的方式比实现Comparator接口的耦合性要强一些，如果要修改比较算法，要修改Comparable接口的实现类，而实现Comparator的类是在外部进行比较的，不需要对实现类有任何修改。从这个角度说，其实有些不太好，尤其在我们将实现类的.class文件打成一个.jar文件提供给开发者使用的时候。实际上实现Comparator接口的方式后面会写到就是一种典型的**策略模式**。

2. 不可变类Immutable

   什么是不可变类：

   1. 该类的实例对象一旦创建，则其成员变量的值就无法改变，即对象的状态一旦创建则无法改变
   2. 基本类型的包装类和String类都是不可变类
   3. 不可变类是线程安全的
   4. 不可变类的对象非常适合做Map对象的Key

   如何设计一个不可变类：

   1. 类声明为final，不能被继承
   2. 类中的成员变量声明为final和private
   3. 不提供改变成员变量的方法
   4. 通过构造器初始化话成员变量时，如果传入的是引用类型，则需要进行深拷贝(`clone()`方法)
   5. 对象必须被正确的创建，**对象引用在对象创建过程中不能泄露**

3. 对象逃逸

4. Void类：void关键字的包装类，用于标记返回类型为void。反射或者泛型中可以标记对应类型为Void。该类使用final修饰，并且构造器为private，不可以被实例化。











参考：

1. 不要让你的Java对象"逃逸"了！https://blog.csdn.net/zxm317122667/article/details/105804078