1. java内存区域

   1. 运行时数据区域

      ![jvm运行时数据区域](../../image/java/jvm运行时数据区域.png)

      1. 程序计数器(Program Counter Register)：**当前线程所执行字节码的行号指示器。**

      2. Java虚拟机栈：描述的是Java方法执行的内存模型，**当前线程私有。**

         每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用和returnAddress类型(指向了一条字节码指令的地址)。

         **该区域会发生两类异常：StackOverflowError和OutOfMemoryError。**

      3. 本地方法栈：**为本地方法(native method)服务**，作用同Java虚拟机栈，**同样也会出现StackOverflowError和OutOfMemoryError异常**

      4. Java堆：**线程共享的区域，存放对象实例。会出现OutOfMemoryError异常。**

      5. 方法区：**线程共享的区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译期编译后的代码等数据。这部分内存区域也会出现OutOfMemoryError异常。**

      6. 运行时常量池：方法区的一部分。存放编译期生成的各种字面量和符号引用。注意，常量不一定只有编译期才能产生，运行期也可能将新的常量放入池中，例如String类的intern()方法。

      7. 直接内存：NIO可以使用Native函数库直接分配堆外内存，然后通过一个存储在堆内的对象作为这块内存的引用，用于提高操作性能。该块内存不受堆内存大小的限制，但是因为是动态申请的，所以也会出现OutOfMemoryError。

2. 对象的创建

   ![JVM中对象的创建](../../image/java/JVM中对象的创建.png)

3. 栈内存如何操作堆内存中的对象

   1. 使用句柄

      ![使用句柄访问对象](../../image/java/使用句柄访问对象.jpg)

      句柄中包含对象实例数据的指针和对象类型数据的指针，这样访问对象需要通过二次指针定位，但是在GC后，对象地址移动后，reference的值不用改变。

   2. 直接指针

      ![直接指针访问对象](../../image/java/直接指针访问对象.jpg)

      可以直接通过reference的值访问到对象，但是需要考虑对象类型数据的存放，并且GC之后，reference的值也需要改变。HotSpot采用的是这种方式。

4. 判断对象不可用的算法

   1. 引数计数算法

      ![引用计数算法对象相互引用](../../image/java/引用计数算法对象相互引用.png)

      每当一个对象有地方引用时，该对象的引用计数器就加一。对象的引用计数器为0时，就表示该对象不可用。存在的问题是：当对象间相互引用时，这些对象的引用计数器永远都不会为0，最终导致，这些对象永远不会被回收。

   2. 可达性分析算法

      一个对象不能到达GC Root的话，说明该对象是不可用的。

      GC Root：

      1. 虚拟机栈中本地变量中引用的对象
      2. 方法区中静态变量引用的对象
      3. 方法区中常量引用的对象
      4. 本地方法栈中(JNI，即Native方法)引用的对象

